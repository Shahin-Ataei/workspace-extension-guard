/**
 * Workspace Extension Guard
 * Enforces extension consistency across workspaces.
 */

const vscode = require('vscode');
const fs = require('fs');
const path = require('path');
const cp = require('child_process');

const SNAPSHOT_FILE = 'workspace-snapshot.json';
const VSCODE_CONFIG_FILE = 'extensions.json';

function activate(context) {

    // --- Command: Export Snapshot ---
    let exportCmd = vscode.commands.registerCommand('extGuard.exportSnapshot', async () => {
        const workspaceFolders = vscode.workspace.workspaceFolders;
        if (!workspaceFolders) {
            vscode.window.showErrorMessage('Please open a workspace folder first.');
            return;
        }

        const rootPath = workspaceFolders[0].uri.fsPath;
        const vscodeDir = path.join(rootPath, '.vscode');
        const snapshotPath = path.join(vscodeDir, SNAPSHOT_FILE);

        const activeExtensions = vscode.extensions.all
            .filter(ext => !ext.packageJSON.isBuiltin)
            .map(ext => ({
                id: ext.id.toLowerCase(),
                version: ext.packageJSON.version
            }))
            .sort((a, b) => a.id.localeCompare(b.id));

        if (!fs.existsSync(vscodeDir)) fs.mkdirSync(vscodeDir);

        const data = {
            description: "Auto-generated by Extension Guard. Do not edit manually.",
            updatedAt: new Date().toISOString(),
            extensions: activeExtensions
        };

        fs.writeFile(snapshotPath, JSON.stringify(data, null, 2), (err) => {
            if (err) vscode.window.showErrorMessage('Failed to save snapshot: ' + err.message);
            else {
                vscode.window.showInformationMessage(`Snapshot saved with ${activeExtensions.length} extensions.`);
                updateVsCodeConfig(rootPath, activeExtensions.map(e => e.id), []);
            }
        });
    });

    // --- Command: Manual Sync ---
    let syncCmd = vscode.commands.registerCommand('extGuard.syncNow', () => {
        performSync(true);
    });

    context.subscriptions.push(exportCmd);
    context.subscriptions.push(syncCmd);

    // --- Auto-Run on Startup ---
    performSync(false);
}

async function getCliCommand() {
    const config = vscode.workspace.getConfiguration('extGuard');
    let cmd = config.get('cliCommand');
    if (cmd && cmd !== 'auto') return cmd;
    if (vscode.env.appName.includes('Insiders')) return 'code-insiders';
    if (vscode.env.appName.includes('Codium')) return 'codium';
    return 'code';
}

function getInstalledExtensionsMap(cliCommand) {
    return new Promise((resolve, reject) => {
        cp.exec(`${cliCommand} --list-extensions --show-versions`, (err, stdout, stderr) => {
            if (err) return reject(stderr || err.message);
            const map = new Map();
            stdout.split('\n').forEach(line => {
                const trimmed = line.trim();
                if (!trimmed) return;
                const parts = trimmed.split('@');
                if (parts.length >= 2) {
                    const version = parts.pop();
                    const id = parts.join('@').toLowerCase();
                    map.set(id, version);
                }
            });
            resolve(map);
        });
    });
}

async function performSync(manualTrigger) {
    const workspaceFolders = vscode.workspace.workspaceFolders;
    if (!workspaceFolders) return;
    const rootPath = workspaceFolders[0].uri.fsPath;
    const snapshotPath = path.join(rootPath, '.vscode', SNAPSHOT_FILE);

    if (!fs.existsSync(snapshotPath)) {
        if (manualTrigger) vscode.window.showErrorMessage("No snapshot found. Please run 'Export Current State' first.");
        return;
    }

    const cliCmd = await getCliCommand();

    let snapshotExtensions = [];
    try {
        const data = JSON.parse(fs.readFileSync(snapshotPath, 'utf8'));
        snapshotExtensions = data.extensions;
    } catch (e) {
        vscode.window.showErrorMessage("Error reading workspace-snapshot.json.");
        return;
    }

    let installedMap;
    try {
        installedMap = await getInstalledExtensionsMap(cliCmd);
    } catch (e) {
        if (manualTrigger) {
            const act = await vscode.window.showErrorMessage(`CLI Error: Command '${cliCmd}' failed.`, "Open Settings");
            if (act === "Open Settings") vscode.commands.executeCommand('workbench.action.openSettings', 'extGuard.cliCommand');
        }
        return;
    }

    const toInstall = [];
    const unwantedIDs = [];
    const globalIgnored = vscode.workspace.getConfiguration('extGuard').get('globalIgnoredExtensions') || [];
    const normalizedIgnored = globalIgnored.map(id => id.toLowerCase());

    snapshotExtensions.forEach(snap => {
        const currentVer = installedMap.get(snap.id);
        if (!currentVer || currentVer !== snap.version) {
            toInstall.push(snap);
        }
    });

    const snapshotIDs = snapshotExtensions.map(e => e.id);
    for (const [id, version] of installedMap) {
        if (!snapshotIDs.includes(id) && !normalizedIgnored.includes(id)) {
            unwantedIDs.push(id);
        }
    }

    if (toInstall.length > 0) {
        const msg = `Found ${toInstall.length} extensions to sync (Install/Update).`;
        const choice = await vscode.window.showInformationMessage(msg, "Install & Update", "Cancel");
        if (choice === "Install & Update") {
            await installExtensionsWithFallback(cliCmd, toInstall);
        }
    }

    updateVsCodeConfig(rootPath, snapshotIDs, unwantedIDs);

    if (manualTrigger && toInstall.length === 0) {
        vscode.window.showInformationMessage("Extensions are fully synced.");
    }
}

async function installExtensionsWithFallback(cliCmd, extensions) {
    await vscode.window.withProgress({
        location: vscode.ProgressLocation.Notification,
        title: "Syncing Extensions...",
        cancellable: false
    }, async (progress) => {
        for (let i = 0; i < extensions.length; i++) {
            const ext = extensions[i];
            progress.report({ message: `Processing ${ext.id}...` });
            const success = await tryInstall(cliCmd, `${ext.id}@${ext.version}`);
            if (!success) {
                console.warn(`Version ${ext.version} failed for ${ext.id}. Trying latest...`);
                await tryInstall(cliCmd, ext.id);
            }
        }
        vscode.window.showInformationMessage("Sync process finished. Reload recommended.");
    });
}

function tryInstall(cliCmd, extString) {
    return new Promise(resolve => {
        cp.exec(`${cliCmd} --install-extension ${extString} --force`, (err) => resolve(!err));
    });
}

function updateVsCodeConfig(rootPath, recommended, unwanted) {
    const configPath = path.join(rootPath, '.vscode', VSCODE_CONFIG_FILE);
    let config = {};
    if (fs.existsSync(configPath)) {
        try { config = JSON.parse(fs.readFileSync(configPath, 'utf8')); } catch (e) {}
    }
    config.recommendations = recommended.sort();
    config.unwantedRecommendations = unwanted.sort();
    fs.writeFileSync(configPath, JSON.stringify(config, null, 2));
}

function deactivate() {}
module.exports = { activate, deactivate };
